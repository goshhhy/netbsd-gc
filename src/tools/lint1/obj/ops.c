/* Automatically generated file; do not edit */
#include <sys/types.h>
#include "op.h"
#include "param.h"
#ifndef __arraycount
#define __arraycount(a) (sizeof(a) / sizeof(a[0]))
#endif /* __arraycount */
mod_t modtab[NOPS];
static const struct {
	mod_t	m;
	unsigned char	ok;
} imods[] = {
	{ /* NOOP */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "no-op" }, 0 },
	{ /* ARROW */	{ 1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, "->" }, 1 },
	{ /* POINT */	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "." }, 1 },
	{ /* NOT */	{ 0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0, "!" }, 1 },
	{ /* COMPL */	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1, "~" }, 1 },
	{ /* INC */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "p + 1" }, 0 },
	{ /* DEC */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "p - 1" }, 0 },
	{ /* INCBEF */	{ 0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "++p" }, 1 },
	{ /* DECBEF */	{ 0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "--p" }, 1 },
	{ /* INCAFT */	{ 0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p++" }, 1 },
	{ /* DECAFT */	{ 0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p--" }, 1 },
	{ /* UPLUS */	{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0, "+p" }, 1 },
	{ /* UMINUS */	{ 0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,0, "-p" }, 1 },
	{ /* STAR */	{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, "*p" }, 1 },
	{ /* AMPER */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "&p" }, 1 },
	{ /* MULT */	{ 1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0, "p * p" }, 1 },
	{ /* DIV */	{ 1,0,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,0, "p / p" }, 1 },
	{ /* MOD */	{ 1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0, "p % p" }, 1 },
	{ /* PLUS */	{ 1,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0, "p + p" }, 1 },
	{ /* MINUS */	{ 1,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0, "p - p" }, 1 },
	{ /* SHL */	{ 1,0,1,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0, "p << p" }, 1 },
	{ /* SHR */	{ 1,0,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0, "p >> p" }, 1 },
	{ /* LT */	{ 1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0, "p < p" }, 1 },
	{ /* LE */	{ 1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0, "p <= p" }, 1 },
	{ /* GT */	{ 1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0, "p > p" }, 1 },
	{ /* GE */	{ 1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0, "p >= p" }, 1 },
	{ /* EQ  */	{ 1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0, "p == p" }, 1 },
	{ /* NE */	{ 1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0, "p != p" }, 1 },
	{ /* AND */	{ 1,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0, "p & p" }, 1 },
	{ /* XOR  */	{ 1,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0, "p ^ p " }, 1 },
	{ /* OR */	{ 1,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0, "p | p" }, 1 },
	{ /* LOGAND */	{ 1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0, "p && p" }, 1 },
	{ /* LOGOR */	{ 1,1,0,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0, "p || p" }, 1 },
	{ /* QUEST */	{ 1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0, "?" }, 1 },
	{ /* COLON */	{ 1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0, ":" }, 1 },
	{ /* ASSIGN */	{ 1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0, "p = p" }, 1 },
	{ /* MULASS */	{ 1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0, "p *= p" }, 1 },
	{ /* DIVASS */	{ 1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0, "p /= p" }, 1 },
	{ /* MODASS */	{ 1,0,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0, "p %= p" }, 1 },
	{ /* ADDASS */	{ 1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p += p" }, 1 },
	{ /* SUBASS */	{ 1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p -= p" }, 1 },
	{ /* SHLASS */	{ 1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p << p" }, 1 },
	{ /* SHRASS  */	{ 1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p >> p" }, 1 },
	{ /* ANDASS */	{ 1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p &= p" }, 1 },
	{ /* XORASS */	{ 1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p ^= p" }, 1 },
	{ /* ORASS */	{ 1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0, "p |= p" }, 1 },
	{ /* NAME */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "n" }, 1 },
	{ /* CON  */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "const" }, 1 },
	{ /* STRING */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "char *" }, 1 },
	{ /* FSEL */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "fsel" }, 1 },
	{ /* CALL */	{ 1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0, "p()" }, 1 },
	{ /* COMMA */	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0, "," }, 1 },
	{ /* CVT */	{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, "(cast)p" }, 1 },
	{ /* ICALL */	{ 1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0, "icall" }, 1 },
	{ /* LOAD */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "load" }, 1 },
	{ /* PUSH */	{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, "push" }, 1 },
	{ /* RETURN */	{ 1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0, "return" }, 1 },
	{ /* REAL */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "p.re" }, 0 },
	{ /* IMAG */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "p.im" }, 0 },
	{ /* INIT */	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0, "p = {}" }, 1 },
	{ /* CASE */	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, "case" }, 0 },
	{ /* FARG */	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0, "f(p)" }, 1 },
};
const char *
getopname(op_t op) {
	return imods[op].m.m_name;
}
void
initmtab(void)
{
	size_t i;

	for (i = 0; i < __arraycount(imods); i++)
		if (imods[i].ok)
			STRUCT_ASSIGN(modtab[i], imods[i].m);
}
